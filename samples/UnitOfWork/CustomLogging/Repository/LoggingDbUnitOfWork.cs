using Aeon.Core.Repository.Infrastructure;
using Microsoft.EntityFrameworkCore;
using System.Collections.Generic;
using System.Linq;

namespace Aeon.Samples.UnitOfWork.CustomLogging.Repository {

    /// <summary>
    /// UnitOfWork that logs tracked changes to entities to the same database
    /// </summary>
    /// <typeparam name="TAuditEntity">Entity type used for persisting audit entries</typeparam>
    /// <typeparam name="TContext">The DbContext type used for tracking ánd persisting audit entries</typeparam>
    public abstract class LoggingDbUnitOfWork<TAuditEntity, TContext> : LoggingDbUnitOfWork<TAuditEntity, TContext, TContext>
         where TAuditEntity : class
         where TContext : DbContext {

        public LoggingDbUnitOfWork(IRepository<TAuditEntity> auditRepository,
                                   TContext dbContext,
                                   System.Func<LoggingDbUnitOfWorkAuditItem<TAuditEntity>, TAuditEntity> mapAuditItemToEntity)
            : base(auditRepository, dbContext, dbContext, mapAuditItemToEntity) {
        }
    }

    /// <summary>
    /// UnitOfWork that logs tracked changes to entities each in their own database
    /// </summary>
    /// <typeparam name="TAuditEntity">Entity type used for persisting audit entries</typeparam>
    /// <typeparam name="TTrackedContext">The DbContext type used for tracking changes</typeparam>
    /// <typeparam name="TAuditContext">>The DbContext type used to persist audit entries</typeparam>
    public abstract class LoggingDbUnitOfWork<TAuditEntity, TTrackedContext, TAuditContext> : IUnitOfWork
        where TAuditEntity : class
        where TTrackedContext : DbContext
        where TAuditContext : DbContext {

        protected readonly TTrackedContext _trackedDbContext;
        protected readonly TAuditContext _auditDbContext;

        protected readonly IRepository<TAuditEntity> _auditRepository;
        protected readonly System.Func<LoggingDbUnitOfWorkAuditItem<TAuditEntity>, TAuditEntity> _mapAuditItemToEntity;

        /// <summary>
        /// Creates a new LoggingDbUnitOfWork instance
        /// </summary>
        /// <param name="auditRepository">The repository used for persisting audit entries</param>
        /// <param name="trackedDbContext">The DbContext used for tracking changes</param>
        /// <param name="auditDbContext">The DbContext used to persist audit entries</param>
        /// <param name="mapAuditEntryToEntity">Mapping function </param>
        protected LoggingDbUnitOfWork(IRepository<TAuditEntity> auditRepository,
                                      TTrackedContext trackedDbContext,
                                      TAuditContext auditDbContext,
                                      System.Func<LoggingDbUnitOfWorkAuditItem<TAuditEntity>, TAuditEntity> mapAuditItemToEntity) {
            _trackedDbContext = trackedDbContext;
            _auditDbContext = auditDbContext;
            _auditRepository = auditRepository;
            _mapAuditItemToEntity = mapAuditItemToEntity;
        }

        public void Commit() {
            Commit(true);
        }

        public void Commit(bool auditEnabled) {
            System.Diagnostics.Debug.WriteLine($"Commit :: {_trackedDbContext.GetType().Name}={((object)_trackedDbContext).GetHashCode()}");
            System.Diagnostics.Debug.WriteLine($"Audit :: {_auditDbContext.GetType().Name}={((object)_auditDbContext).GetHashCode()}");
            if (auditEnabled) {
                var auditEntries = OnBeforeSaveChanges();
                // save data changes
                _trackedDbContext.SaveChanges();
                // save audit changes
                _auditDbContext.SaveChanges();
                if (OnAfterSaveChanges(auditEntries)) {
                    // data entries have changed, so might 've audit entries
                    _auditDbContext.SaveChanges();
                }
            } else {
                _trackedDbContext.SaveChanges();
            }
        }


        private List<LoggingDbUnitOfWorkAuditItem<TAuditEntity>> OnBeforeSaveChanges() {

            _trackedDbContext.ChangeTracker.DetectChanges();
            var auditEntries = new List<LoggingDbUnitOfWorkAuditItem<TAuditEntity>>();

            foreach (var entry in _trackedDbContext.ChangeTracker.Entries()) {
                if (entry.Entity is TAuditEntity || entry.State == EntityState.Detached || entry.State == EntityState.Unchanged)
                    continue;

                var auditEntry = new LoggingDbUnitOfWorkAuditItem<TAuditEntity>() { ModelName = entry.Entity.GetType().Name };
                auditEntries.Add(auditEntry);

                foreach (var property in entry.Properties) {
                    if (property.IsTemporary) {
                        // value will be generated by the database, get the value after saving
                        auditEntry.TemporaryProperties.Add(property);
                        continue;
                    }

                    string propertyName = property.Metadata.Name;
                    if (property.Metadata.IsPrimaryKey()) {
                        auditEntry.KeyValues[propertyName] = property.CurrentValue;
                        continue;
                    }

                    switch (entry.State) {
                        case EntityState.Added:
                            auditEntry.NewValues[propertyName] = property.CurrentValue;
                            break;

                        case EntityState.Deleted:
                            auditEntry.OldValues[propertyName] = property.OriginalValue;
                            break;

                        case EntityState.Modified:
                            if (property.IsModified) {
                                auditEntry.OldValues[propertyName] = property.OriginalValue;
                                auditEntry.NewValues[propertyName] = property.CurrentValue;
                            }
                            break;
                    }
                }
            }

            // Save audit entities that have all the modifications
            foreach (var auditEntry in auditEntries) {
                _auditRepository.Add(_mapAuditItemToEntity(auditEntry));
            }

            // keep a list of entries where the value of some properties are unknown at this step (eg. filled by the database)
            return auditEntries.Where(a => a.HasTemporaryProperties).ToList();
        }

        private bool OnAfterSaveChanges(List<LoggingDbUnitOfWorkAuditItem<TAuditEntity>> auditEntries) {
            if (auditEntries == null || auditEntries.Count == 0)
                return false;

            foreach (var auditEntry in auditEntries) {
                // Get the final value of the temporary properties
                foreach (var prop in auditEntry.TemporaryProperties) {
                    if (prop.Metadata.IsPrimaryKey()) {
                        auditEntry.KeyValues[prop.Metadata.Name] = prop.CurrentValue;
                    } else {
                        auditEntry.NewValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                }

                // update Audit entity(-Keyvalues, since those could've been just set on our data)
                _auditRepository.Update(_mapAuditItemToEntity(auditEntry));
            }

            return true;
        }

    }
}